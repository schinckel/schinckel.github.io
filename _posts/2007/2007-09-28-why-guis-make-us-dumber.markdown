--- 
wordpress_id: 1264
layout: post
title: Why GUIs make us dumber.
time: "12:29:14"
date: 2007-09-28 12:29:14
tags: 
- programming
wordpress_url: http://schinckel.net/2007/09/28/why-guis-make-us-dumber/
---
I've been teaching a Year 12 Information Technology course this year. In some ways I've enjoyed it (it's the first time I've actually ever been paid for doing something to do with computer programming, and it has helped me to make the decision to go back to Uni and complete my degree in this area), but in lots of ways I really haven't.

I don't know how much the students are to blame (and I'm game making a statement like that, since some of them read this blog). I'm thinking more and more that perhaps there is something else that isn't making them succeed as much as I would have liked. It may be that the group of students I have just aren't motivated in the way I was as a student, or perhaps even I wasn't at their age. This may be true, since I was busy dropping out of Uni when I was about 18, after all.

But I was still teaching myself stuff to do with programming at that age. Whether it was logo or Basic at school, Pascal C or C++ at University, or Python, JavaScript and AppleScript since then, I've continued to learn stuff related to coding my whole life. I even taught myself Amiga E back when I had an A1200.

Perhaps there is an overstatement with the title to this post. I'm not sure that GUIs do indeed make us dumber. It's a little more complicated than that.

Back in the 70s, 80s, and even the early 90s, computers really weren't that universal. You could do all sorts of things without having to use a computer. Now, computers are everywhere. The idea that everyone would rely on a world-wide computer network for a significant amount of their social interaction was something that was limited to science fiction books. And even they mostly underestimated just how much the internet, and computers, would affect our lives.

Because computers weren't so widespread, only a small fraction of the population were using them. Those people were likely to be, perhaps I'd suggest with a touch of smugness, smarter than those who weren't. At least, they were a different type of people. Perhaps the type of people to whom a regimented, logical way of thought was more natural. A group of people who are prepared, and able to memorise strange, obscure sequences of characters and numbers.

Because, back then, that was the only way to interact with computers. I mean, anyone could remember:

`load "*",8,1`  


to load and run a game on a commodore 64. But figuring out why, when you pressed up onto the line labelled `READY.` and pressing return yielded an arcane "`Out Of Data Error`" perhaps required more thought. Being able to grasp the concepts behind programming: the various looping and decision structures was easy to people who saw the world through binary glasses.

Users of computers now don't have to worry any more about getting the command exactly right. You don't have to even remember the dir command, or the C64 load "$",8 to get a listing of a directory. You just double-click an icon that looks like a folder, and you get an automatic list of whatever files and folders are inside of it.

This has taught users that remembering arcane commands isn't important. Until you have to write programs yourself.

This is the biggest thing my students struggle with. Not understanding that a spelling error or typo can have a totally bizarre impact on the execution of a program (or even display or behaviour of a web-page, for those that have only ever used DreamWeaver or FrontPage). This takes the basest manifestation that False has a different meaning in virtually every programming language from false, to not recognising that not having quotes around a string causes the language to attempt to execute it.

I do blame GUIs for these shortfalls in the skills and knowledge of younger people. When the user interface prevents you from making mistakes in data entry, then you don't develop the problem-solving skills to overcome errors in other contexts when they do appear.

And computer programming is all about problem solving. Being able to logically approach an error message, interpret the likely causes and fix the issue requires perhaps more skills than I had anticipated these students would have. Would things have been better for my teaching of this subject if I had students more like myself, who are all busy doing Physics-Chemistry-double-Maths? Perhaps. But I think they too would lack some of the skills required.
